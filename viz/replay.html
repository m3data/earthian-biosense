<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Session Replay — EarthianBioSense</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0a0f;
      color: #e0e0e0;
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    h1 {
      font-size: 14px;
      font-weight: 400;
      letter-spacing: 0.1em;
      color: #666;
      margin-bottom: 15px;
    }

    #tabs {
      display: flex;
      gap: 0;
      margin-bottom: 15px;
    }

    .tab {
      background: #12121a;
      border: 1px solid #222;
      color: #555;
      padding: 10px 24px;
      cursor: pointer;
      font-family: inherit;
      font-size: 11px;
      letter-spacing: 0.05em;
      transition: all 0.2s;
    }

    .tab:first-child {
      border-radius: 4px 0 0 4px;
    }

    .tab:last-child {
      border-radius: 0 4px 4px 0;
      border-left: none;
    }

    .tab:hover {
      background: #1a1a24;
      color: #888;
    }

    .tab.active {
      background: #1a1a28;
      border-color: #333;
      color: #aaa;
    }

    #file-input-container {
      margin-bottom: 15px;
    }

    #file-input {
      display: none;
    }

    #file-label {
      cursor: pointer;
      padding: 8px 16px;
      background: #1a1a24;
      border: 1px dashed #333;
      border-radius: 4px;
      font-size: 12px;
      color: #666;
      transition: all 0.2s;
    }

    #file-label:hover {
      border-color: #555;
      color: #999;
    }

    #session-name {
      font-size: 11px;
      color: #444;
      margin-top: 8px;
      text-align: center;
    }

    #canvas-container {
      border: 1px solid #222;
      border-radius: 4px;
      overflow: hidden;
    }

    #controls {
      margin-top: 20px;
      display: flex;
      gap: 15px;
      align-items: center;
    }

    button {
      background: #1a1a24;
      border: 1px solid #333;
      color: #aaa;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 12px;
      transition: all 0.2s;
    }

    button:hover {
      background: #252535;
      border-color: #444;
      color: #ddd;
    }

    button.active {
      background: #2a2a3a;
      border-color: #556;
      color: #fff;
    }

    #timeline-container {
      margin-top: 15px;
      width: 100%;
      max-width: 800px;
    }

    #timeline {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: #1a1a24;
      border-radius: 3px;
      cursor: pointer;
    }

    #timeline::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: #7a6f9d;
      border-radius: 50%;
      cursor: pointer;
    }

    #time-display {
      margin-top: 8px;
      font-size: 11px;
      color: #555;
      display: flex;
      justify-content: space-between;
    }

    #metrics-panel {
      margin-top: 20px;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      width: 100%;
      max-width: 800px;
    }

    .metric {
      background: #12121a;
      border: 1px solid #1a1a24;
      border-radius: 4px;
      padding: 12px;
    }

    .metric-label {
      font-size: 10px;
      color: #555;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .metric-value {
      font-size: 18px;
      color: #aaa;
      margin-top: 4px;
    }

    .metric-sub {
      font-size: 10px;
      color: #444;
      margin-top: 2px;
    }

    #phase-label {
      font-size: 12px;
      color: #7a6f9d;
      margin-top: 15px;
      font-style: italic;
    }

    #view-hint {
      font-size: 10px;
      color: #444;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>PHENOMENOLOGICAL REPLAY</h1>

  <div id="tabs">
    <div class="tab active" data-view="2d">2D Temporal</div>
    <div class="tab" data-view="3d">3D Topology</div>
  </div>

  <div id="file-input-container">
    <label id="file-label" for="file-input">Load Session (.jsonl)</label>
    <input type="file" id="file-input" accept=".jsonl">
    <div id="session-name"></div>
  </div>

  <div id="canvas-container"></div>

  <div id="view-hint"></div>

  <div id="controls">
    <button id="play-btn">Play</button>
    <button id="speed-05">0.5x</button>
    <button id="speed-1" class="active">1x</button>
    <button id="speed-2">2x</button>
    <button id="speed-4">4x</button>
  </div>

  <div id="timeline-container">
    <input type="range" id="timeline" min="0" max="100" value="0">
    <div id="time-display">
      <span id="time-current">00:00</span>
      <span id="time-total">00:00</span>
    </div>
  </div>

  <div id="phase-label">— waiting for session —</div>

  <div id="metrics-panel">
    <div class="metric">
      <div class="metric-label">Heart Rate</div>
      <div class="metric-value" id="m-hr">—</div>
      <div class="metric-sub">bpm</div>
    </div>
    <div class="metric">
      <div class="metric-label">Coherence</div>
      <div class="metric-value" id="m-coh">—</div>
      <div class="metric-sub" id="m-coh-label">—</div>
    </div>
    <div class="metric">
      <div class="metric-label">Breath</div>
      <div class="metric-value" id="m-breath">—</div>
      <div class="metric-sub">cycles/min</div>
    </div>
    <div class="metric">
      <div class="metric-label">Stability</div>
      <div class="metric-value" id="m-stability">—</div>
      <div class="metric-sub" id="m-mode">—</div>
    </div>
  </div>

  <script>
// === Session Data ===
let sessionData = [];
let currentIndex = 0;
let isPlaying = false;
let playbackSpeed = 1;
let lastFrameTime = 0;
const TRAIL_LENGTH = 80;

// === View Mode ===
let currentView = '2d';  // '2d' or '3d'
let p5Instance = null;

// === 3D Camera State ===
let cam3D = {
  rotX: -0.4,
  rotY: 0.3,
  rotZ: 0,
  zoom: 1,
  autoRotate: true,
  dragging: false,
  lastMouseX: 0,
  lastMouseY: 0
};

// === Dwell Density (computed from session) ===
let dwellDensity = [];
const DENSITY_GRID = 20;

// === Visual Settings ===
const WIDTH = 800;
const HEIGHT = 500;
const MARGIN = 60;

// Mode color palette
const MODE_COLORS = {
  'heightened vigilance': [255, 120, 80],
  'subtle vigilance': [220, 180, 100],
  'settling': [100, 160, 200],
  'transitional': [180, 150, 200],
  'emerging coherence': [120, 200, 160],
  'coherent': [100, 220, 180],
  'deep coherence': [80, 240, 200]
};

// === Initialize p5 ===
function initP5(mode) {
  if (p5Instance) {
    p5Instance.remove();
  }

  let sketch = mode === '3d' ? sketch3D : sketch2D;
  p5Instance = new p5(sketch, 'canvas-container');

  // Update hint
  let hint = document.getElementById('view-hint');
  if (mode === '3d') {
    hint.textContent = 'drag to rotate · scroll to zoom';
  } else {
    hint.textContent = '';
  }
}

// === 2D Sketch ===
let sketch2D = function(p) {
  p.setup = function() {
    p.createCanvas(WIDTH, HEIGHT);
    p.frameRate(60);
    p.textFont('monospace');
  };

  p.draw = function() {
    p.background(10, 10, 15);

    if (sessionData.length === 0) {
      drawWaitingState2D(p);
      return;
    }

    handlePlayback();
    drawAxes2D(p);
    drawTrail2D(p);
    drawCurrentPosition2D(p);
    drawCoherenceIndicator2D(p);
    drawLegend2D(p);
  };
};

function drawWaitingState2D(p) {
  p.fill(60);
  p.noStroke();
  p.textAlign(p.CENTER, p.CENTER);
  p.textSize(12);
  p.text('Load a session to begin', WIDTH/2, HEIGHT/2);
}

function drawAxes2D(p) {
  p.stroke(30);
  p.strokeWeight(1);

  for (let i = 0; i <= 10; i++) {
    let x = p.map(i, 0, 10, MARGIN, WIDTH - MARGIN);
    let y = p.map(i, 0, 10, HEIGHT - MARGIN, MARGIN);
    p.line(x, MARGIN, x, HEIGHT - MARGIN);
    p.line(MARGIN, y, WIDTH - MARGIN, y);
  }

  p.fill(50);
  p.noStroke();
  p.textSize(10);
  p.textAlign(p.CENTER, p.TOP);
  p.text('coherence', WIDTH/2, HEIGHT - 25);

  p.push();
  p.translate(20, HEIGHT/2);
  p.rotate(-p.HALF_PI);
  p.textAlign(p.CENTER, p.BOTTOM);
  p.text('breath rhythm', 0, 0);
  p.pop();
}

function drawTrail2D(p) {
  if (sessionData.length === 0) return;

  let startIdx = Math.max(0, Math.floor(currentIndex) - TRAIL_LENGTH);
  let endIdx = Math.floor(currentIndex);

  let points = [];
  for (let i = startIdx; i <= endIdx; i++) {
    let sample = sessionData[i];
    let pos = sampleToCanvas2D(sample, p);
    let zPhase = sample.phase.position[2] || 0.5;

    points.push({
      x: pos.x, y: pos.y, z: zPhase,
      mode: sample.metrics.mode,
      stability: sample.phase.stability || 0.5
    });
  }

  if (points.length < 2) return;

  let vanishY = HEIGHT * 0.35;
  let vanishX = WIDTH * 0.5;
  let depthScale = 0.6;

  function perspectiveTransform(pt, age) {
    let depth = age * depthScale + (1 - pt.z) * 0.15;
    let px = p.lerp(pt.x, vanishX, depth * 0.4);
    let py = p.lerp(pt.y, vanishY, depth * 0.5);
    let scale = p.map(depth, 0, 1, 1, 0.3);
    return { x: px, y: py, scale: scale, depth: depth };
  }

  p.noFill();

  for (let i = 0; i < points.length - 1; i++) {
    let age = (points.length - 1 - i) / TRAIL_LENGTH;
    let nextAge = (points.length - 2 - i) / TRAIL_LENGTH;

    let p1 = perspectiveTransform(points[i], age);
    let p2 = perspectiveTransform(points[Math.min(i + 1, points.length - 1)], nextAge);

    let alpha = p.map(age, 0, 1, 200, 15);
    let weight = p.map(age, 0, 1, 5, 0.5) * p1.scale;

    let col = getModeColor(points[i].mode);
    let nextCol = getModeColor(points[Math.min(i + 1, points.length - 1)].mode);

    let softness = p.map(points[i].stability, 0, 1, 0.4, 1);
    alpha *= softness;

    let saturationFade = p.map(age, 0, 1, 1, 0.5);
    let gray = (col[0] + col[1] + col[2]) / 3;

    p.stroke(
      p.lerp(p.lerp(col[0], gray, 1 - saturationFade), p.lerp(nextCol[0], gray, 1 - saturationFade), 0.5),
      p.lerp(p.lerp(col[1], gray, 1 - saturationFade), p.lerp(nextCol[1], gray, 1 - saturationFade), 0.5),
      p.lerp(p.lerp(col[2], gray, 1 - saturationFade), p.lerp(nextCol[2], gray, 1 - saturationFade), 0.5),
      alpha
    );
    p.strokeWeight(weight);

    if (i < points.length - 1) {
      let p0t = perspectiveTransform(points[Math.max(0, i - 1)], (points.length - i) / TRAIL_LENGTH);
      let p3t = perspectiveTransform(points[Math.min(i + 2, points.length - 1)], (points.length - 3 - i) / TRAIL_LENGTH);

      let tension = 0.4;
      let cx1 = p1.x + (p2.x - p0t.x) * tension / 3;
      let cy1 = p1.y + (p2.y - p0t.y) * tension / 3;
      let cx2 = p2.x - (p3t.x - p1.x) * tension / 3;
      let cy2 = p2.y - (p3t.y - p1.y) * tension / 3;

      p.bezier(p1.x, p1.y, cx1, cy1, cx2, cy2, p2.x, p2.y);
    }
  }

  p.noStroke();
  for (let i = 0; i < 20; i++) {
    let a = p.map(i, 0, 20, 8, 0);
    p.fill(40, 40, 50, a);
    let y = vanishY + i * 2;
    p.rect(MARGIN, y, WIDTH - MARGIN * 2, 2);
  }
}

function drawCurrentPosition2D(p) {
  if (sessionData.length === 0) return;

  let idx = Math.floor(currentIndex);
  let sample = sessionData[idx];
  let pos = sampleToCanvas2D(sample, p);

  let amp = sample.metrics.amp || 50;
  let size = p.map(amp, 0, 300, 16, 45);

  let col = getModeColor(sample.metrics.mode);
  let stability = sample.phase.stability || 0.5;

  p.noStroke();
  for (let r = size * 3; r > size; r -= 3) {
    let alpha = p.map(r, size, size * 3, 80 * stability, 0);
    p.fill(col[0], col[1], col[2], alpha);
    p.ellipse(pos.x, pos.y, r, r);
  }

  p.fill(col[0], col[1], col[2], 255);
  p.ellipse(pos.x, pos.y, size, size);

  p.fill(255, 255, 255, 180);
  p.ellipse(pos.x, pos.y, size * 0.35, size * 0.35);

  let hr = sample.hr || 75;
  let pulsePhase = (p.millis() / (60000 / hr)) % 1;
  let pulseSize = size * (1 + Math.sin(pulsePhase * p.TWO_PI) * 0.08);
  p.noFill();
  p.stroke(255, 255, 255, 30);
  p.strokeWeight(1);
  p.ellipse(pos.x, pos.y, pulseSize * 1.5, pulseSize * 1.5);
}

function drawCoherenceIndicator2D(p) {
  if (sessionData.length === 0) return;

  let idx = Math.floor(currentIndex);
  let sample = sessionData[idx];
  let coh = sample.phase.coherence || 0;

  let barWidth = p.map(coh, 0, 1, 0, WIDTH - MARGIN * 2);

  p.noStroke();
  p.fill(30);
  p.rect(MARGIN, 15, WIDTH - MARGIN * 2, 6, 3);

  let col = getModeColor(sample.metrics.mode);
  p.fill(col[0], col[1], col[2], 180);
  p.rect(MARGIN, 15, barWidth, 6, 3);
}

function drawLegend2D(p) {
  let legendX = WIDTH - 145;
  let legendY = MARGIN + 10;
  let swatchSize = 10;
  let lineHeight = 18;

  let modes = [
    ['heightened vigilance', 'heightened'],
    ['subtle vigilance', 'subtle vigilance'],
    ['transitional', 'transitional'],
    ['settling', 'settling'],
    ['emerging coherence', 'emerging'],
    ['deep coherence', 'coherent']
  ];

  p.noStroke();
  p.fill(10, 10, 15, 220);
  p.rect(legendX - 12, legendY - 8, 140, modes.length * lineHeight + 16, 4);

  p.stroke(40);
  p.strokeWeight(1);
  p.noFill();
  p.rect(legendX - 12, legendY - 8, 140, modes.length * lineHeight + 16, 4);

  p.noStroke();
  p.fill(80);
  p.textSize(9);
  p.textAlign(p.LEFT, p.TOP);
  p.text('MODE', legendX, legendY - 4);

  legendY += 14;

  for (let i = 0; i < modes.length; i++) {
    let [key, label] = modes[i];
    let col = MODE_COLORS[key] || [150, 150, 150];

    p.noStroke();
    p.fill(col[0], col[1], col[2], 60);
    p.ellipse(legendX + swatchSize/2, legendY + i * lineHeight + swatchSize/2, swatchSize + 4, swatchSize + 4);

    p.fill(col[0], col[1], col[2], 200);
    p.ellipse(legendX + swatchSize/2, legendY + i * lineHeight + swatchSize/2, swatchSize, swatchSize);

    p.fill(120);
    p.textSize(10);
    p.textAlign(p.LEFT, p.CENTER);
    p.text(label, legendX + swatchSize + 8, legendY + i * lineHeight + swatchSize/2);
  }
}

function sampleToCanvas2D(sample, p) {
  // Use phase.coherence (trajectory integrity) for x-axis
  let coh = sample.phase.coherence || 0;
  let x = p.map(coh, 0, 1, MARGIN, WIDTH - MARGIN);
  let breathPos = sample.phase.position[1];
  let y = p.map(breathPos, 0, 1, HEIGHT - MARGIN, MARGIN);
  return { x, y };
}

// === 3D Sketch ===
let sketch3D = function(p) {
  p.setup = function() {
    p.createCanvas(WIDTH, HEIGHT, p.WEBGL);
    p.frameRate(60);
    p.textFont('monospace');
  };

  p.draw = function() {
    p.background(10, 10, 15);

    if (sessionData.length === 0) {
      drawWaitingState3D(p);
      return;
    }

    handlePlayback();

    // Camera setup
    let zoom = cam3D.zoom * 250;
    p.camera(0, 0, zoom, 0, 0, 0, 0, 1, 0);

    // Auto-rotate
    if (cam3D.autoRotate && !cam3D.dragging) {
      cam3D.rotY += 0.002;
    }

    p.rotateX(cam3D.rotX);
    p.rotateY(cam3D.rotY);

    drawAxes3D(p);
    drawDwellDensity3D(p);
    drawTrail3D(p);
    drawCurrentPosition3D(p);
    drawLegend3D(p);
  };

  p.mousePressed = function() {
    if (p.mouseX > 0 && p.mouseX < WIDTH && p.mouseY > 0 && p.mouseY < HEIGHT) {
      cam3D.dragging = true;
      cam3D.lastMouseX = p.mouseX;
      cam3D.lastMouseY = p.mouseY;
    }
  };

  p.mouseReleased = function() {
    cam3D.dragging = false;
  };

  p.mouseDragged = function() {
    if (cam3D.dragging) {
      let dx = p.mouseX - cam3D.lastMouseX;
      let dy = p.mouseY - cam3D.lastMouseY;
      cam3D.rotY += dx * 0.01;
      cam3D.rotX += dy * 0.01;
      cam3D.rotX = p.constrain(cam3D.rotX, -p.HALF_PI, p.HALF_PI);
      cam3D.lastMouseX = p.mouseX;
      cam3D.lastMouseY = p.mouseY;
    }
  };

  p.mouseWheel = function(event) {
    if (p.mouseX > 0 && p.mouseX < WIDTH && p.mouseY > 0 && p.mouseY < HEIGHT) {
      cam3D.zoom += event.delta * 0.001;
      cam3D.zoom = p.constrain(cam3D.zoom, 0.5, 3);
      return false;
    }
  };
};

function drawWaitingState3D(p) {
  p.fill(60);
  p.noStroke();
  p.textAlign(p.CENTER, p.CENTER);
  p.textSize(12);
  p.text('Load a session to begin', 0, 0);
}

function drawAxes3D(p) {
  let axisLen = 120;

  p.strokeWeight(1);

  // X axis - Coherence (red tint)
  p.stroke(100, 60, 60, 150);
  p.line(-axisLen, 0, 0, axisLen, 0, 0);

  // Y axis - Stability (green tint)
  p.stroke(60, 100, 60, 150);
  p.line(0, -axisLen, 0, 0, axisLen, 0);

  // Z axis - Breath/Amplitude (blue tint)
  p.stroke(60, 60, 100, 150);
  p.line(0, 0, -axisLen, 0, 0, axisLen);

  // Grid on XZ plane (floor)
  p.stroke(30, 30, 40, 80);
  p.strokeWeight(0.5);
  for (let i = -100; i <= 100; i += 20) {
    p.line(i, 80, -100, i, 80, 100);
    p.line(-100, 80, i, 100, 80, i);
  }

  // Axis labels
  p.push();
  p.fill(80);
  p.noStroke();
  p.textSize(8);

  // Coherence label
  p.push();
  p.translate(axisLen + 15, 0, 0);
  p.rotateY(p.HALF_PI);
  p.text('COH', 0, 0);
  p.pop();

  // Stability label
  p.push();
  p.translate(0, -axisLen - 15, 0);
  p.text('STAB', 0, 0);
  p.pop();

  // Breath/Amp label
  p.push();
  p.translate(0, 0, axisLen + 15);
  p.text('AMP', 0, 0);
  p.pop();

  p.pop();
}

function drawDwellDensity3D(p) {
  // Draw attractor basins as subtle background context
  if (dwellDensity.length === 0) return;

  let maxDensity = Math.max(...dwellDensity.flat().flat()) || 1;

  // Draw as soft, transparent halos - not solid spheres
  p.noFill();

  for (let xi = 0; xi < DENSITY_GRID; xi++) {
    for (let yi = 0; yi < DENSITY_GRID; yi++) {
      for (let zi = 0; zi < DENSITY_GRID; zi++) {
        let density = dwellDensity[xi]?.[yi]?.[zi] || 0;
        if (density < 2) continue;  // Higher threshold to reduce clutter

        let normDensity = density / maxDensity;

        // Position in 3D space
        let x = p.map(xi, 0, DENSITY_GRID, -100, 100);
        let y = p.map(yi, 0, DENSITY_GRID, 80, -80);
        let z = p.map(zi, 0, DENSITY_GRID, -100, 100);

        // Color based on position (coherence gradient)
        let cohFactor = xi / DENSITY_GRID;
        let col = lerpColor3(
          [220, 180, 100],  // Low coherence - vigilance
          [100, 200, 180],  // High coherence
          cohFactor
        );

        let size = p.map(normDensity, 0, 1, 8, 35);

        // Draw as concentric rings (wireframe halo effect)
        p.push();
        p.translate(x, y, z);

        // Multiple soft rings at different orientations
        for (let ring = 0; ring < 3; ring++) {
          let ringAlpha = p.map(normDensity, 0, 1, 8, 25) * (1 - ring * 0.3);
          let ringSize = size * (1 + ring * 0.3);

          p.stroke(col[0], col[1], col[2], ringAlpha);
          p.strokeWeight(0.5);

          p.push();
          if (ring === 0) p.rotateX(p.HALF_PI);
          else if (ring === 1) p.rotateY(p.HALF_PI);
          // ring 2 stays at default orientation

          // Draw circle
          p.beginShape();
          for (let a = 0; a < p.TWO_PI; a += 0.3) {
            let px = Math.cos(a) * ringSize;
            let py = Math.sin(a) * ringSize;
            p.vertex(px, py, 0);
          }
          p.endShape(p.CLOSE);
          p.pop();
        }

        p.pop();
      }
    }
  }
}

function drawTrail3D(p) {
  if (sessionData.length === 0) return;

  let startIdx = Math.max(0, Math.floor(currentIndex) - TRAIL_LENGTH);
  let endIdx = Math.floor(currentIndex);

  // Collect points for smoothing
  let points = [];
  for (let i = startIdx; i <= endIdx; i++) {
    let sample = sessionData[i];
    let pos = sampleToCanvas3D(sample);
    points.push({
      x: pos.x, y: pos.y, z: pos.z,
      mode: sample.metrics.mode
    });
  }

  if (points.length < 3) return;

  // Generate smoothed curve using Catmull-Rom interpolation
  let smoothedPoints = [];
  let subdivisions = 3; // Points between each sample

  for (let i = 0; i < points.length - 1; i++) {
    let p0 = points[Math.max(0, i - 1)];
    let p1 = points[i];
    let p2 = points[Math.min(i + 1, points.length - 1)];
    let p3 = points[Math.min(i + 2, points.length - 1)];

    for (let t = 0; t < subdivisions; t++) {
      let tNorm = t / subdivisions;

      // Catmull-Rom spline interpolation
      let tension = 0.5;
      let t2 = tNorm * tNorm;
      let t3 = t2 * tNorm;

      let x = 0.5 * ((2 * p1.x) +
        (-p0.x + p2.x) * tNorm +
        (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 +
        (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3);

      let y = 0.5 * ((2 * p1.y) +
        (-p0.y + p2.y) * tNorm +
        (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 +
        (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3);

      let z = 0.5 * ((2 * p1.z) +
        (-p0.z + p2.z) * tNorm +
        (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) * t2 +
        (-p0.z + 3 * p1.z - 3 * p2.z + p3.z) * t3);

      smoothedPoints.push({
        x, y, z,
        mode: p1.mode,
        originalIdx: i
      });
    }
  }
  // Add final point
  smoothedPoints.push({
    x: points[points.length - 1].x,
    y: points[points.length - 1].y,
    z: points[points.length - 1].z,
    mode: points[points.length - 1].mode,
    originalIdx: points.length - 1
  });

  p.noFill();

  // Draw trail with glow effect - outer glow first, then core
  for (let pass = 0; pass < 2; pass++) {
    for (let i = 0; i < smoothedPoints.length - 1; i++) {
      let pt = smoothedPoints[i];
      let nextPt = smoothedPoints[i + 1];

      let age = (smoothedPoints.length - 1 - i) / smoothedPoints.length;
      let col = getModeColor(pt.mode);

      // Desaturate with age
      let gray = (col[0] + col[1] + col[2]) / 3;
      let satFade = p.map(age, 0, 1, 1, 0.5);

      if (pass === 0) {
        // Outer glow pass
        let alpha = p.map(age, 0, 1, 50, 5);
        let weight = p.map(age, 0, 1, 8, 2);

        p.stroke(
          p.lerp(col[0], gray, 1 - satFade),
          p.lerp(col[1], gray, 1 - satFade),
          p.lerp(col[2], gray, 1 - satFade),
          alpha
        );
        p.strokeWeight(weight);
      } else {
        // Core pass - brighter, thinner
        let alpha = p.map(age, 0, 1, 255, 30);
        let weight = p.map(age, 0, 1, 3, 0.8);

        p.stroke(
          p.lerp(col[0], gray, 1 - satFade),
          p.lerp(col[1], gray, 1 - satFade),
          p.lerp(col[2], gray, 1 - satFade),
          alpha
        );
        p.strokeWeight(weight);
      }

      p.line(pt.x, pt.y, pt.z, nextPt.x, nextPt.y, nextPt.z);
    }
  }
}

function drawCurrentPosition3D(p) {
  if (sessionData.length === 0) return;

  let idx = Math.floor(currentIndex);
  let sample = sessionData[idx];
  let pos = sampleToCanvas3D(sample);

  let amp = sample.metrics.amp || 50;
  let size = p.map(amp, 0, 300, 8, 20);

  let col = getModeColor(sample.metrics.mode);
  let stability = sample.phase.stability || 0.5;

  // Glow layers
  p.noStroke();
  for (let r = 3; r >= 1; r--) {
    let alpha = p.map(r, 1, 3, 180, 30) * stability;
    p.fill(col[0], col[1], col[2], alpha);
    p.push();
    p.translate(pos.x, pos.y, pos.z);
    p.sphere(size * r * 0.7);
    p.pop();
  }

  // Core
  p.fill(col[0], col[1], col[2], 255);
  p.push();
  p.translate(pos.x, pos.y, pos.z);
  p.sphere(size);
  p.pop();

  // Inner bright core
  p.fill(255, 255, 255, 200);
  p.push();
  p.translate(pos.x, pos.y, pos.z);
  p.sphere(size * 0.3);
  p.pop();
}

function drawLegend3D(p) {
  // Draw HUD overlay in screen space
  // Reset to 2D orthographic view for clean text rendering
  p.push();

  // Disable depth test for HUD
  p.drawingContext.disable(p.drawingContext.DEPTH_TEST);

  // Reset camera to orthographic 2D
  p.ortho(-WIDTH/2, WIDTH/2, -HEIGHT/2, HEIGHT/2, -1000, 1000);
  p.resetMatrix();

  // Position in top-right corner (matching 2D view)
  let legendX = WIDTH/2 - 155;
  let legendY = -HEIGHT/2 + 70;
  let swatchSize = 10;
  let lineHeight = 18;

  let modes = [
    ['heightened vigilance', 'heightened'],
    ['subtle vigilance', 'subtle vigilance'],
    ['transitional', 'transitional'],
    ['settling', 'settling'],
    ['emerging coherence', 'emerging'],
    ['deep coherence', 'coherent']
  ];

  // Background panel
  p.noStroke();
  p.fill(10, 10, 15, 230);
  p.rect(legendX - 12, legendY - 8, 145, modes.length * lineHeight + 24, 4);

  // Border
  p.stroke(50);
  p.strokeWeight(1);
  p.noFill();
  p.rect(legendX - 12, legendY - 8, 145, modes.length * lineHeight + 24, 4);

  // Title
  p.noStroke();
  p.fill(100);
  p.textSize(10);
  p.textAlign(p.LEFT, p.TOP);
  p.text('MODE', legendX, legendY - 2);

  legendY += 18;

  // Mode entries
  for (let i = 0; i < modes.length; i++) {
    let [key, label] = modes[i];
    let col = MODE_COLORS[key] || [150, 150, 150];

    // Glow behind swatch
    p.noStroke();
    p.fill(col[0], col[1], col[2], 50);
    p.ellipse(legendX + swatchSize/2, legendY + i * lineHeight + swatchSize/2, swatchSize + 6, swatchSize + 6);

    // Swatch
    p.fill(col[0], col[1], col[2], 220);
    p.ellipse(legendX + swatchSize/2, legendY + i * lineHeight + swatchSize/2, swatchSize, swatchSize);

    // Label
    p.fill(140);
    p.textSize(11);
    p.textAlign(p.LEFT, p.CENTER);
    p.text(label, legendX + swatchSize + 10, legendY + i * lineHeight + swatchSize/2);
  }

  // Re-enable depth test
  p.drawingContext.enable(p.drawingContext.DEPTH_TEST);

  p.pop();
}

function sampleToCanvas3D(sample) {
  // X: Coherence (0-1) -> -100 to 100
  let coh = sample.phase.coherence || 0;
  let x = (coh - 0.5) * 200;

  // Y: Stability (0-1) -> 80 to -80 (inverted so high stability is "up")
  let stability = sample.phase.stability || 0.5;
  let y = (0.5 - stability) * 160;

  // Z: Amplitude / phase.position[2] (0-1) -> -100 to 100
  let ampPos = sample.phase.position[2] || 0.5;
  let z = (ampPos - 0.5) * 200;

  return { x, y, z };
}

function lerpColor3(c1, c2, t) {
  return [
    c1[0] + (c2[0] - c1[0]) * t,
    c1[1] + (c2[1] - c1[1]) * t,
    c1[2] + (c2[2] - c1[2]) * t
  ];
}

// === Compute Dwell Density ===
function computeDwellDensity() {
  // Initialize 3D grid
  dwellDensity = [];
  for (let x = 0; x < DENSITY_GRID; x++) {
    dwellDensity[x] = [];
    for (let y = 0; y < DENSITY_GRID; y++) {
      dwellDensity[x][y] = [];
      for (let z = 0; z < DENSITY_GRID; z++) {
        dwellDensity[x][y][z] = 0;
      }
    }
  }

  // Accumulate dwell time
  for (let sample of sessionData) {
    let coh = sample.phase.coherence || 0;
    let stability = sample.phase.stability || 0.5;
    let ampPos = sample.phase.position[2] || 0.5;

    let xi = Math.floor(coh * (DENSITY_GRID - 1));
    let yi = Math.floor(stability * (DENSITY_GRID - 1));
    let zi = Math.floor(ampPos * (DENSITY_GRID - 1));

    xi = Math.max(0, Math.min(DENSITY_GRID - 1, xi));
    yi = Math.max(0, Math.min(DENSITY_GRID - 1, yi));
    zi = Math.max(0, Math.min(DENSITY_GRID - 1, zi));

    dwellDensity[xi][yi][zi]++;
  }
}

// === Shared Functions ===
function handlePlayback() {
  if (isPlaying) {
    let now = performance.now();
    let elapsed = now - lastFrameTime;
    let msPerSample = 2000 / playbackSpeed;

    if (elapsed > msPerSample / 60) {
      if (currentIndex < sessionData.length - 1) {
        currentIndex += (elapsed / msPerSample);
        currentIndex = Math.min(currentIndex, sessionData.length - 1);
        updateUI();
      } else {
        isPlaying = false;
        document.getElementById('play-btn').textContent = 'Play';
      }
      lastFrameTime = now;
    }
  }
}

function getModeColor(mode) {
  for (let key in MODE_COLORS) {
    if (mode && mode.includes(key.split(' ')[0])) {
      return MODE_COLORS[key];
    }
  }
  return [150, 150, 150];
}

function updateUI() {
  if (sessionData.length === 0) return;

  let idx = Math.floor(currentIndex);
  let sample = sessionData[idx];

  document.getElementById('m-hr').textContent = sample.hr || '—';
  // Use phase.coherence (trajectory integrity) instead of old metrics.coh
  let coh = sample.phase.coherence || 0;
  document.getElementById('m-coh').textContent = coh.toFixed(2);
  // Show entrainment label as secondary info
  document.getElementById('m-coh-label').textContent = sample.metrics.ent_label || '—';
  document.getElementById('m-breath').textContent = sample.metrics.breath ? sample.metrics.breath.toFixed(1) : '—';
  document.getElementById('m-stability').textContent = sample.phase.stability ? sample.phase.stability.toFixed(2) : '—';
  document.getElementById('m-mode').textContent = sample.metrics.mode || '—';

  document.getElementById('phase-label').textContent = sample.phase.phase_label || '—';
  document.getElementById('timeline').value = (currentIndex / (sessionData.length - 1)) * 100;

  let startTime = new Date(sessionData[0].ts);
  let currentTime = new Date(sample.ts);
  let elapsed = (currentTime - startTime) / 1000;
  let total = (new Date(sessionData[sessionData.length - 1].ts) - startTime) / 1000;

  document.getElementById('time-current').textContent = formatTime(elapsed);
  document.getElementById('time-total').textContent = formatTime(total);
}

function formatTime(seconds) {
  let mins = Math.floor(seconds / 60);
  let secs = Math.floor(seconds % 60);
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

// === Event Handlers ===
document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    currentView = tab.dataset.view;
    initP5(currentView);
  });
});

document.getElementById('file-input').addEventListener('change', async (e) => {
  let file = e.target.files[0];
  if (!file) return;

  let text = await file.text();
  let lines = text.trim().split('\n');
  let parsed = lines.map(line => JSON.parse(line));

  // Filter out header records (type: "session_start") and any records without phase data
  sessionData = parsed.filter(record => record.phase && record.metrics);

  currentIndex = 0;
  isPlaying = false;
  document.getElementById('play-btn').textContent = 'Play';
  document.getElementById('session-name').textContent = file.name;
  document.getElementById('phase-label').textContent = '— ready —';

  computeDwellDensity();
  updateUI();
});

document.getElementById('play-btn').addEventListener('click', () => {
  if (sessionData.length === 0) return;

  isPlaying = !isPlaying;
  document.getElementById('play-btn').textContent = isPlaying ? 'Pause' : 'Play';
  lastFrameTime = performance.now();

  if (currentIndex >= sessionData.length - 1) {
    currentIndex = 0;
  }
});

document.getElementById('timeline').addEventListener('input', (e) => {
  if (sessionData.length === 0) return;
  currentIndex = (e.target.value / 100) * (sessionData.length - 1);
  updateUI();
});

['05', '1', '2', '4'].forEach(speed => {
  document.getElementById(`speed-${speed}`).addEventListener('click', (e) => {
    playbackSpeed = speed === '05' ? 0.5 : parseInt(speed);
    document.querySelectorAll('#controls button').forEach(btn => {
      if (btn.id.startsWith('speed-')) btn.classList.remove('active');
    });
    e.target.classList.add('active');
  });
});

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space') {
    e.preventDefault();
    document.getElementById('play-btn').click();
  }
  if (e.code === 'ArrowLeft') {
    currentIndex = Math.max(0, currentIndex - 10);
    updateUI();
  }
  if (e.code === 'ArrowRight') {
    currentIndex = Math.min(sessionData.length - 1, currentIndex + 10);
    updateUI();
  }
});

// Initialize with 2D view
initP5('2d');
  </script>
</body>
</html>
